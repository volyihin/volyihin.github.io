<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Удаление символов из строки</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The personal blog of J. Michael McGarr, professional automation rant monger.  Passionate about #devops #continuousDelivery #lean #agile">
    <meta name="author" content="https://twitter.com/SonOfGarr">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/asciidoctor.css" rel="stylesheet">
    <link href="/css/base.css" rel="stylesheet">
    <link href="/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="/css/extra.css" rel="stylesheet">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,300,400' rel='stylesheet' type='text/css'>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="/favicon.ico">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-49993013-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
  </head>
  <body>
    <div id="fb-root"></div>
      <script>(function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));</script>
    <script src="//platform.linkedin.com/in.js" type="text/javascript">
     lang: en_US
    </script>
    <div id="wrap">

	<!-- Fixed navbar -->
      <div class="navbar navbar-fixed-top">
        <div class="navbar-inner">
          <div class="container">
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="brand" href="/">Volyihin</a>
            <div class="nav-collapse collapse">
              <ul class="nav">
                <li><a href="/about.html">About</a></li>
                <li><a href="/archive.html">Posts</a></li>
                <li><a href="/travel/index.html">Travel</a></li>
                <li><a href="/feed.xml">Subscribe</a></li>
              </ul>
            </div><!--/.nav-collapse -->
          </div>
        </div>
      </div>
      <div class="container-fluid">
    <div class="row-fluid">

				<div class="span6 offset3">

					<div class="page-header">
						<h1>Удаление символов из строки</h1>
					</div>

					<p><em>June 24, 2015</em></p>

				</div>
		</div>


		<div class="row-fluid">

				<div class="span2 offset1">
					<p/>
					<p class="text-right"><em></em>
								<a href="/tags/algorithm.html">algorithm</a><br/>
					</p>
				</div>

        <div class="span6">

        	<p><h2>Задача </h2><p>Написать функцию, которая удалит символы из строки.</p><p><code><br/>string removeChars( string str, string remove );<br/></code><br/>Символы, которые содержатся в //str//, удалить из //remove// .<br/>Пример.<br/> Дана строка //Battle of the Vowels: Hawaii vs. Grozny//.  Удалить //aeiou//. Функция  //removeChars// вернёт такой результат - //Bttl f th Vwls: Hw vs. Grzny//. </p><h2>Решение</h2><p>Разделим задачу на две части. Для каждого символа определим - удалять ли его? Потом, само удаление соответствующего символа. Сначала мы обсудим удаление символа.<br/>Удаление символа из строки алгоритмически эквивалентно удалению элемента из массива. В памяти массив хранится одним блоком, так что не получится удалить элемент из середины эффективно, как можно было бы сделать со связным списком.<br/>Вместо этого в массиве мы переставим элементы таким образом, чтобы  вместо удаляемого элемента сразу шли следующие за ним. Если мы удалим символ //c// из строки //abcd//, то мы можем либо двинуть символы //ab// на одну позицию вперед, либо сдвинуть символ //d// на одну позицию назад. Оба подхода приводят к одному и тому же результату - //abd//. <br/>Кроме того, подвинув данные, также уменьшим размер строки на один символ. Получается, в первом случае мы уничтожим первый элемент, а во втором - последний. В большинстве языков программирования гораздо легче удалять элемент с конца массива(либо уменьшая длину строки на один, либо записывая последним элементом //null//, в зависимости от языка) чем с начала, поэтому сдвигать символы в начало это наилучший вариант.<br/>Каково время работы алгоритма в наихудшем случае, если мы удалим все символы в строке //str//? Для каждого удаления потребуется сдвигать остальные символы назад на одну позицию. Если строка длинны //n//, то потребуется сдвинуть последний символ //n - 1// раз, предпоследний - //n - 2// раза. В итоге //O(n^2)// на удаление. <br/>Если мы удалим символы строки с конца, то получится немного эффективнее, но сложность останется такая же - //O(n^2)// в худшем случае. Сдвигать один и тот же символ несколько раз подряд не очень эффективно. Попробуем избежать этого. Что если создать строковый буфер и модифицировать его вместо исходной строки? Затем мы копируем символы из буфера, пропуская те символы, которые удалим. Когда закончится построение результирующей строки, то можно скопировать ее в исходную. Каждый символ передвигается как минимум 2 раза, что в итоге дает удаление за //O(n)//.<br/>Однако мы приобретаем затраты на память этого буфера, который размером с исходную строка, и затраты на копирование обратно уже итоговой строки. </p><p>Получается, что мы перемещаем каждый символ как минимум дважды, вместо O(n) удаления. Однако, мы несем затраты по памяти на вернменный буфер, который такого же размера как и исходная строка, и затраты на копирование модифицированной строки обратно в исходную. Попробуем избежать этих издержек, но оставить сложность алгоритма O(n).</p><p>Для релаизации O(n) алгоритма мы будем следить за позицеей символа в исходной строке и позицией символа в строке-буфере. Обе позиции изначально равны 0.<br/>Значение первой позиции мы увеличим на один, когда будем читать из строки, а значение второй позиции - когда будем записывать в буфер.</p><p>Другими словами, когда мы копируем символ, мы увеличваем значения обоих счетчиков на единицу, но когда мы удаляем символ, мы увеличиваем только исходный счетчик. Значит, исходный счетчик имеет либо такое же значение, либо больше чем значние счетчика буфера.</p><p>После того, как мы прочитали символ из исходной строки ( счетчик прошел этот символ), мы больше не нуждаемся в этом символе - потому что затем мы скопируем модифицированную строку поверх него.<br/>---------------------</p><p>To implement the O(n) algorithm just described, you need to track a source position for the read<br/>location in the original string and a destination position for the write position in the temporary buffer.<br/>These positions both start at zero. </p><p>The source position is incremented every time you read, and<br/>the destination position is incremented every time you write. </p><p>In other words, when you copy a character,<br/>you increment both positions, but when you delete a character, you increment only the source<br/>position. This means the source position is always the same as or ahead of the destination position.</p><p>After you read a character from the original string (that is, the source position has advanced past it),<br/>you no longer need that character — because you’re just going to copy the modified string over it.</p><p>Because the destination position in the original string is always a character you don’t need anymore,<br/>you can write directly into the original string, eliminating the temporary buffer entirely. </p><p>This is still an O(n) algorithm but without the memory and time overhead of the earlier version.<br/>Now that you know how to delete characters, consider the task of deciding whether to delete a particular<br/>character. </p><p>The easiest way to do this is to compare the character to each character in remove<br/>and delete it if it matches any of them. </p><p>How efficient is this? If str is n characters long and remove is<br/>m characters long, then in the worst case you make m comparisons for each of n characters, so the<br/>algorithm is O(nm). You can’t avoid checking each of the n characters in str, but perhaps you can<br/>make the lookup that determines whether a given character is in remove better than O(m).<br/>If you’ve already read the solution to “Find the First Nonrepeated Character,” this should sound<br/>familiar. Just as you did in that problem, you can use remove to build an array or hash table that<br/>has constant time lookup, thus giving an O(n) solution. The trade-offs between hash tables and<br/>arrays are the same as previously discussed. In this case, an array is most appropriate when str<br/>and remove are long and characters have relatively few possible values (for example, ASCII strings).<br/>A hash table may be a better choice when str and remove are short or characters have many possible<br/>values (for example, Unicode strings). Either choice could be acceptable as long as you justify it<br/>appropriately. This time, you’re told that the inputs are ASCII strings, so the array wouldn’t be too<br/>big; because the previous implementation used a hash table, try using an array for this one.</p></p>

					<p><em>Share this:</em></p>
          <p style="float:left">
                <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://www.mikemcgarr.com/blog/2015/remove_specified_characters.html" data-via="SonOfGarr" data-lang="fr">Tweeter</a>
                <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
                <div class="g-plusone" data-size="medium" data-href="http://www.mikemcgarr.com/blog/2015/remove_specified_characters.html"></div>
                <script type="IN/Share" data-url="http://www.mikemcgarr.com/blog/2015/remove_specified_characters.html" data-counter="right"></script>
                <div class="fb-like" data-href="http://www.mikemcgarr.com/blog/2015/remove_specified_characters.html" data-layout="button_count" data-action="like" data-show-faces="false" data-share="true"></div>
          </p>

          <hr>

          <div id="disqus_thread">
          <script type="text/javascript">
                var disqus_shortname = 'mikemcgarr';
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
          <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
        </div>
    </div>

		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
        <p class="muted credit">All posts on this blog are published with a <em>Creative Commons by-nc-sa</em> license.<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"/></a></p>
        <p class="muted credit">&copy; 2015 | Mixed with <a href="http://twitter.github.com/bootstrap/">Bootstrap v2.3.1</a> | Baked with <a href="http://jbake.org">JBake v2.4.0</a></p>
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/js/jquery-1.9.1.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/run_prettify.js"></script>
    <script type="text/javascript">
      (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/platform.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      })();
    </script>
  </body>
</html>
