<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Обзор книги &quot;Netty in Action&quot;</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="The personal blog of J. Michael McGarr, professional automation rant monger.  Passionate about #devops #continuousDelivery #lean #agile">
    <meta name="author" content="https://twitter.com/SonOfGarr">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/asciidoctor.css" rel="stylesheet">
    <link href="/css/base.css" rel="stylesheet">
    <link href="/css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="/css/extra.css" rel="stylesheet">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,300,400' rel='stylesheet' type='text/css'>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="/js/html5shiv.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="/favicon.ico">
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-49993013-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
  </head>
  <body>
    <div id="fb-root"></div>
      <script>(function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));</script>
    <script src="//platform.linkedin.com/in.js" type="text/javascript">
     lang: en_US
    </script>
    <div id="wrap">

	<!-- Fixed navbar -->
      <div class="navbar navbar-fixed-top">
        <div class="navbar-inner">
          <div class="container">
            <button type="button" class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="brand" href="/">Volyihin</a>
            <div class="nav-collapse collapse">
              <ul class="nav">
                <li><a href="/about.html">About</a></li>
                <li><a href="/archive.html">Posts</a></li>
                <li><a href="/travel/index.html">Travel</a></li>
                <li><a href="/feed.xml">Subscribe</a></li>
              </ul>
            </div><!--/.nav-collapse -->
          </div>
        </div>
      </div>
      <div class="container-fluid">
    <div class="row-fluid">

				<div class="span6 offset3">

					<div class="page-header">
						<h1>Обзор книги &quot;Netty in Action&quot;</h1>
					</div>

					<p><em>January 22, 2015</em></p>

				</div>
		</div>


		<div class="row-fluid">

				<div class="span2 offset1">
					<p/>
					<p class="text-right"><em></em>
								<a href="/tags/book.html">book</a><br/>
					</p>
				</div>

        <div class="span6">

        	<p><div class="sect1">
<h2 id="_Блокирующий_против_неблокирующего_ввода_вывода_в_jvm"><a class="anchor" href="#_Блокирующий_против_неблокирующего_ввода_вывода_в_jvm"></a>Блокирующий против неблокирующего ввода-вывода в JVM</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Продолжающийся рост веба увеличивает потребность в обработке все большего количества данных через сеть и возможностей масштабирования. Эффективность приложений выходит на первое место и встречается со спросом на эту эффективность. К счастью, Java уже поставляется со всеми инструментами, необходимыми для создания эффективных и масштабируемых приложений. Хотя ранние версии Java поддерживали работу с сетью, в Java 1.4 был представлен NIO API, который упрощал разработку клиент-серверных приложений.</p>
</div>
<div class="paragraph">
<p>Новый ввод-вывод (NIO.2), представленный в Java 7, дает возможность писать асинхронный, работающий с сетью код и также предлагает более высокоуровневый API , чем его предшественник.</p>
</div>
<div class="paragraph">
<p>Для работы с сетью у вас есть всего два варианта:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Использовать IO, известный как блокирующий ввод-вывод</p>
</li>
<li>
<p>Использовать NIO, известный как новый/неблокирующий ввод-вывод</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="../../img/blocking.png" alt="blocking">
</div>
<div class="title">Figure 1. Блокирующие сокеты</div>
</div>
<div class="imageblock">
<div class="content">
<img src="../../img/nonblocking.png" alt="nonblocking">
</div>
<div class="title">Figure 2. Неблокирующие сокеты</div>
</div>
<div class="paragraph">
<p>На рисунках 1,2 показано, что блокирующий ввод-вывод использует по выделенному потоку на на каждое соединение, это означает, что мы имеем связь один-к-одному между подключениями и потоками, которая ограничивает количество потоков, которое может создать JVM.</p>
</div>
<div class="paragraph">
<p>Запомнив это концептуальное отличие, попробуем написать простой сервер, используя разные подходы.
Сервер будет принимать запросы от клиента, и отправлять их назад.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;

public class PlainEchoServer {
    public void serve(int port) throws IOException {
        final ServerSocket socket = new ServerSocket(port); <i class="conum" data-value="1"></i><b>(1)</b>
        try {
            while (true) {
                final Socket clientSocket = socket.accept(); <i class="conum" data-value="2"></i><b>(2)</b>
                System.out.println("Accepted connection from " +
                        clientSocket);
                new Thread(new Runnable() { <i class="conum" data-value="3"></i><b>(3)</b>
                    @Override
                    public void run() {
                        try {
                            BufferedReader reader = new BufferedReader(
                                    new
                                            InputStreamReader(clientSocket.getInputStream()));
                            PrintWriter writer = new PrintWriter(clientSocket
                                    .getOutputStream(), true);
                            while(true) { <i class="conum" data-value="4"></i><b>(4)</b>
                                writer.println(reader.readLine());
                                writer.flush();

                            }
                        } catch (IOException e) {
                            e.printStackTrace();
                            try {
                                clientSocket.close();
                            } catch (IOException ex) {
                                // ignore on close
                            }
                        }
                    }
                }).start(); <i class="conum" data-value="5"></i><b>(5)</b>
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws IOException {
        new PlainEchoServer().serve(9000);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Привязываем сервер к порту</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Блокируем основной поток, пока клиент не подключится</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Создаем новый поток и обрабатываем подключение клиента</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Читаем введенные клиентом данные и записываем их назад</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Запускаем поток</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Подключиться к такому серверу можно с помощью <a href="https://ru.wikipedia.org/wiki/Telnet">telnet</a>, например вот так:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-bash" data-lang="bash">telnet localhost 9000</code></pre>
</div>
</div>
<div class="paragraph">
<p>На каждого нового клиента требуется создать отдельный поток. Можно, конечно, сделать какой-нибудь pool потоков, чтобы уменьшить затраты на создание каждый раз нового потока, и переиспользовать уже созданные, но это поможет лишь только на время. Основная проблема все же остается: количество одновременных клиентов будет ограничено количеством потоков, обрабатывающих их. Когда приложению необходимо обрабатывать одновременно тысячи клиентов, это становится большой проблемой.</p>
</div>
<div class="paragraph">
<p>Эта проблема исчезает, если мы будем использовать NIO, как например, в следующем примере. Но для начала важно узнать основные концепции в NIO.</p>
</div>
<div class="sect2">
<h3 id="_Основные_концепции_nio"><a class="anchor" href="#_Основные_концепции_nio"></a>Основные концепции NIO</h3>
<div class="paragraph">
<p>Java 7 представила новый NIO API, известный как NIO.2, но можно так же использовать и "просто" NIO. Хотя новый API также асинхронный, он отличается от исходной реализации NIO, как API, так и реализацией. Хотя API не сильно отличаются, они оба имеют одинаковые возможности. Например, обе реализации используют одну и ту же абстракцию под названием <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html">ByteBuffer</a>, как обертку для данных.</p>
</div>
<div class="sect3">
<h4 id="_bytebuffer"><a class="anchor" href="#_bytebuffer"></a>Bytebuffer</h4>
<div class="paragraph">
<p>ByteBuffer - это основа для обоих NIO APIs, так же как и в Netty. ByteBuffer может быть создан как и в Java куче <em>(heap)</em>, так и напрямую, что означает, что он будет хранится вне кучи. Использование буфера напрямую обычно быстрее, когда мы передаем его какому-то каналу <em>(channel)</em>, но стоимость создание и очистки/удаления такого буфера выше. В обоих случаях, API Bytebuffer&#8217;а один и тот же, который позволяет одним унифицированный образом управлять данными  в буфере. ByteBuffer позволяет одним и тем же данным быть легко доступными между разными экземплярами Bytebuffer, без необходимости копировать внутренние данные. Так же он предоставляет другие операции, который ограничивают видимость внутренних данных.</p>
</div>
<div class="paragraph">
<p>Slicing ByteBuffer</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Разрезание <em>(Slicing)</em> ByteBuffer позволяет создать новый экземпляр, который будет ссылаться на те же данные, как и исходный ByteBuffer, но делать доступным только часть этих данных. Это полезно для минимизации количества копирований данных, но разрешает доступ только к части этих данных.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Типичное использование ByteBuffer включает следущее:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Записать данные в ByteBuffer</p>
</li>
<li>
<p>Вызвать <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html#flip()">ByteBuffer.flip()</a> для смены режима на чтение</p>
</li>
<li>
<p>Чтение данных из ByteBuffer</p>
</li>
<li>
<p>Вызов либо <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html#clear()">ByteBuffer.clear()</a>, либо <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html#compact()">ByteBuffer.compact()</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Когда данные пишутся в ByteBuffer, он следит за количеством данных, записанных в него, сохраняя позицию индекса записи. Перед тем, как прочитать данные нужно вызвать Bytebuffer.flip(), чтобы сменить режим с записи на режим чтения. Вызов метода ByteBuffer.flip() устанавливает ограничение в ByteBuffer в текущую позицию, а затем устанавливает ее в 0. Таким образом можно считать все данные из ByteBuffer.</p>
</div>
<div class="paragraph">
<p>Чтобы опять записать данные в ByteBuffer, нужно вернуться в режим чтения, а затем вызвать следующие методы:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://docs.oracle.com/javase/7/docs/api/java/nio/Buffer.html#clear()">ByteBuffer.clear()</a> Очищает все данные в буфере</p>
</li>
<li>
<p><a href="http://docs.oracle.com/javase/7/docs/api/java/nio/ByteBuffer.html#compact()">ByteBuffer.compact()</a> Очищает только те данные, которые были прочтены, и перемещает все непрочитанные данные в начало и сдвигает позицию, типичное использование:</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">Channel inChannel = ....;
ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = -1;
do {
  bytesRead = inChannel.read(buf); <i class="conum" data-value="1"></i><b>(1)</b>
  if (bytesRead != -1) {
   buf.flip(); <i class="conum" data-value="2"></i><b>(2)</b>
    while(buf.hasRemaining()){
     System.out.print((char) buf.get()); <i class="conum" data-value="3"></i><b>(3)</b>
    }
   buf.clear(); <i class="conum" data-value="4"></i><b>(4)</b>
  }
} while (bytesRead != -1);
inChannel.close();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Прочитать данные из канала <em>(Channel)</em>  в ByteBuffer</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Подготовим буфер для чтения</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Прочитаем байты из ByteBuffer,с каждым вызовом get() обновляем индекс позиции на 1</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Подготовим буфер для записи</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Теперь, когда понятно, как работать с ByteBuffer, рассмотрим концепцию селекторов <em>(Selectors)</em>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_Работа_с_nio_селекторами_em_selectors_em"><a class="anchor" href="#_Работа_с_nio_селекторами_em_selectors_em"></a>Работа с NIO селекторами <em>(Selectors)</em></h3>
<div class="paragraph">
<p>NIO API использует основанный на селекторах подход для обработки сетевых событий и данных. Канал <em>(channel)</em> выступает в роли соединения между сущностями, способными осуществлять операции ввода-вывода над такими сущностями как как файл или сокет. Селектор это NIO компонент, который определяет готов ли канал или несколько каналов для чтения/записи, получается что один селектор способен обработать множество подключений, сводящий на нет необходимость для использования модели поток-на-соединение, как было блокирующем сервере из первого примера.</p>
</div>
<div class="paragraph">
<p>Чтобы использовать селектор нужно выполнит следующие шаги:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Создать один или несколько селекторов, в которых можно зарегистрировать каналы <em>(channels)</em></p>
</li>
<li>
<p>Когда каналы зарегистрированы, нужно указать события,к которые будут прослушиваться. Существует 4 типа событий:</p>
<div class="ulist">
<ul>
<li>
<p>OP_ACCEPT</p>
</li>
<li>
<p>OP_CONNECT</p>
</li>
<li>
<p>OP_READ</p>
</li>
<li>
<p>OP_WRITE</p>
</li>
</ul>
</div>
</li>
<li>
<p>Когда каналы зарегистрированы, необходимо вызвать метод Selector.select(), который заблокирует основной поток, пока какое-нибудь из событий не произойдет.</p>
</li>
<li>
<p>Когда метод разблокируется, можно получить все экземпляры SelectionKey(содержит ссылки на зарегистрированный канал и тип события) и выполнить свой код. Что конкретно выполнять зависит от типа события, которое пришло. SelectedKey может содержать больше чем одно событие в один промежуток времени.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Чтобы увидеть как это работает на деле, нужно реализовать неблокирующую версию сервера из предыдущего примера.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class PlainNioEchoServer {
    public void serve(int port) throws IOException {
        System.out.println("Listening for connections on port " + port);
        ServerSocketChannel serverChannel = ServerSocketChannel.open();
        ServerSocket ss = serverChannel.socket();
        InetSocketAddress address = new InetSocketAddress(port);
        ss.bind(address); <i class="conum" data-value="1"></i><b>(1)</b>
        serverChannel.configureBlocking(false);
        Selector selector = Selector.open();
        serverChannel.register(selector, SelectionKey.OP_ACCEPT); <i class="conum" data-value="2"></i><b>(2)</b>
        while (true) {
            try {
                selector.select(); <i class="conum" data-value="3"></i><b>(3)</b>
            } catch (IOException ex) {
                ex.printStackTrace();
                // handle in a proper way
                break;
            }
            Set readyKeys = selector.selectedKeys();<i class="conum" data-value="4"></i><b>(4)</b>
            Iterator iterator = readyKeys.iterator();
            while (iterator.hasNext()) {
                SelectionKey key = (SelectionKey) iterator.next();
                iterator.remove();//; <i class="conum" data-value="5"></i><b>(5)</b>
                try {
                    if (key.isAcceptable()) {
                        ServerSocketChannel server = (ServerSocketChannel)
                                key.channel();
                        SocketChannel client = server.accept();<i class="conum" data-value="6"></i><b>(6)</b>
                        System.out.println("Accepted connection from " +
                                client);
                        client.configureBlocking(false);
                        client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, ByteBuffer.allocate(100));<i class="conum" data-value="7"></i><b>(7)</b>
                    }
                    if (key.isReadable()) {<i class="conum" data-value="8"></i><b>(8)</b>
                        SocketChannel client = (SocketChannel) key.channel();
                        ByteBuffer output = (ByteBuffer) key.attachment();
                        client.read(output);<i class="conum" data-value="9"></i><b>(9)</b>
                    }
                    if (key.isWritable()) {<i class="conum" data-value="10"></i><b>(10)</b>
                        SocketChannel client = (SocketChannel) key.channel();
                        ByteBuffer output = (ByteBuffer) key.attachment();
                        output.flip();
                        client.write(output);<i class="conum" data-value="11"></i><b>(11)</b>
                        output.compact();
                    }
                } catch (IOException ex) {
                    key.cancel();
                    try {
                        key.channel().close();
                    } catch (IOException cex) {
                    }
                }
            }
        }
    }

    public static void main(String[] args) throws IOException {
        new PlainNioEchoServer().serve(9091);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Привязываем сервер к порту</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Регистрируем канал с селектором для прослушивания событий типа "accept"</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Блокируем пока какой-то селектор не сработает</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Получаем все экземпляры SelectedKey</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Убираем SelectedKey из итератора</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Принимаем соединение клиента</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Регистрируем соединение в селекторе и устанавливаем ByteBuffer</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Проверяем SelectedKey на чтение</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Читаем данные в ByteBuffer</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Проверяем SelectedKey на запись</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Записываем данные их ByteBuffer в канал</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Этот пример гораздо сложнее, чем предыдущая версия. Такая сложность - это своего рода компромисс. Асинхронный код обычно сложнее, чем его синхронная версия. Семантически, исходный NIO и NIO.2 API одинаковые, но на самом деле их реализация разная. Далее мы разработаем 3 версию нашего сервера.</p>
</div>
</div>
<div class="sect2">
<h3 id="_echoserver_основанный_на_nio_2"><a class="anchor" href="#_echoserver_основанный_на_nio_2"></a>EchoServer, основанный на NIO.2</h3>
<div class="paragraph">
<p>В отличие от первой реализации NIO, NIO.2 позволяет отлавливать конкретные операции ввода-вывода и завершить их специальным классом-обработчиком <em>(CompletionHandler)</em>. Это класс должен выполняется после завершения какой-либо операции. Таким образом он запускается внутренним механизмом NIO и реализация скрыта от разработчика. Так же гарантируется,что только один обработчик будет выполняться для одного канала в один промежуток времени. Этот подход позволяет упростить код, потому что убирается вся сложность работы с многопоточным кодом.</p>
</div>
<div class="paragraph">
<p>Основное различие между NIO и NIO.2 это то, что не требуется самому проверять - произошло ли какое-то событие и вызывать необходимый обработчик. В NIO.2 нужно только запустить IO <em>(input-output)</em> операцию и зарегистрировать обработчик <em>(CompletionHandler)</em>, который будет получать уведомления, когда операция завершится. Поэтому необходимость писать свою собственную логику на проверку завершения операция отпадает. Сейчас, давайте посмотрим как будет выглядеть асинхронный <em>EchoServer</em> , реализованный с помощью NIO.2 API.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousServerSocketChannel;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.util.concurrent.CountDownLatch;

public class PlainNio2EchoServer {


    public void serve(int port) throws IOException {
        System.out.println("Listening for connections on port " + port);
        final AsynchronousServerSocketChannel serverChannel =
                AsynchronousServerSocketChannel.open();
        InetSocketAddress address = new InetSocketAddress(port);
        serverChannel.bind(address); <i class="conum" data-value="1"></i><b>(1)</b>
        final CountDownLatch latch = new CountDownLatch(1);
        serverChannel.accept(null, new
                CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() {
                    <i class="conum" data-value="2"></i><b>(2)</b>

                    @Override
                    public void completed(final AsynchronousSocketChannel channel,
                                          Object attachment) {
                        serverChannel.accept(null, this);<i class="conum" data-value="3"></i><b>(3)</b>
                        ByteBuffer buffer = ByteBuffer.allocate(100);
                        channel.read(buffer, buffer,
                                new EchoCompletionHandler(channel));<i class="conum" data-value="4"></i><b>(4)</b>
                    }

                    @Override
                    public void failed(Throwable throwable, Object attachment) {
                        try {
                            serverChannel.close();<i class="conum" data-value="5"></i><b>(5)</b>
                        } catch (IOException e) {
                            // ingnore on close
                        } finally {
                            latch.countDown();
                        }
                    }
                });
        try {
            latch.await();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    private final class EchoCompletionHandler implements
            CompletionHandler&lt;Integer, ByteBuffer&gt; {
        private final AsynchronousSocketChannel channel;

        EchoCompletionHandler(AsynchronousSocketChannel channel) {
            this.channel = channel;
        }

        @Override
        public void completed(Integer result, ByteBuffer buffer) {
            buffer.flip();
            channel.write(buffer, buffer, new CompletionHandler&lt;Integer,
                    ByteBuffer&gt;() {
                <i class="conum" data-value="6"></i><b>(6)</b>

                @Override
                public void completed(Integer result, ByteBuffer buffer) {
                    if (buffer.hasRemaining()) {
                        channel.write(buffer, buffer, this);<i class="conum" data-value="7"></i><b>(7)</b>
                    } else {
                        buffer.compact();
                        channel.read(buffer, buffer,
                                EchoCompletionHandler.this);<i class="conum" data-value="8"></i><b>(8)</b>
                    }
                }

                @Override
                public void failed(Throwable exc, ByteBuffer attachment) {
                    try {
                        channel.close();
                    } catch (IOException e) {
                        // ingnore on close
                    }
                }
            });
        }

        @Override
        public void failed(Throwable exc, ByteBuffer attachment) {
            try {
                channel.close();
            } catch (IOException e) {
                // ingnore on close
            }
        }
    }

    public static void main(String[] args) throws IOException {
        new PlainNio2EchoServer().serve(9092);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Привяжем сервер к порту</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Начинаем принимать новые подключения. Как только соединение установлено - CompletionHandler будет вызван</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Опять принимаем новый соединения</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Запускаем операцию чтения из channel, CompletionHandler будет уведомлен, когда что-нибудь будет прочитано</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Закрываем socket если произошла ошибка</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Запускаем операцию записи в channel, CompletionHandler будет уведомлен, когда что-нибудь будет записано</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Запускаем еще раз операцию чтения, если что-то осталось в ByteBuffer</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Запускаем операцию чтения в channel, CompletionHandler будет уведомлен, когда что-нибудь будет прочитано</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>На первый взгляд может показаться, что в NIO.2 гораздо больше кода, чем в предыдущем примере с NIO. Но можно обратить внимание, что NIO.2 берет обработку многопоточности на себя и также создание так называемого цикла событий <em>(event loop)</em> . Этот подход упрощает разработку многопоточного приложения на NIO, даже если на первый взгляд код кажется сложным. Так как сложность приложений увеличивается, пропасть между этими подходами становится более очевидной, потому что во второй версии получается более читаемый код. Далее мы посмотрим на проблемы, который существуют в обоих реализациях NIO.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_Проблемы_с_nio_и_как_netty_решает_эти_проблемы"><a class="anchor" href="#_Проблемы_с_nio_и_как_netty_решает_эти_проблемы"></a>Проблемы с NIO и как Netty решает эти проблемы</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Далее будут рассмотрены некоторые проблемы и ограничения реализации в Java NIO API, и как Netty решает эти проблемы. Если вы уже используете классы из пакета NIO - это шаг в правильном направлении, но пользователи весьма ограничены в способах его использования. Проблемы, с которыми вы столкнетесь, являются результатом дизайна, который был сделан в прошлом, и который сейчас не так то легко поменять.</p>
</div>
<div class="sect2">
<h3 id="_Проблемы_кроссплатформенности_и_совместимости"><a class="anchor" href="#_Проблемы_кроссплатформенности_и_совместимости"></a>Проблемы кроссплатформенности и совместимости</h3>
<div class="paragraph">
<p>NIO фреймворк довольно низкоуровневый и сильно зависит от того, как сама операционная система обрабатывает операции ввода-вывода. Поэтому выполнить требование унифицированного API в Java, который должен вести себя одинаково на всех платформах, не очень простая задача.</p>
</div>
<div class="paragraph">
<p>Когда используешь NIO часто можно заметить, что код хорошо работает под Linux, например, в отличие от Windows. Это утверждение справедливо, кстати, не только для NIO.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Даже если вы не используете NIO, очень важно тестировать ваше приложение на всех операционных системах, которые хотите поддерживать. Если все ваши тесты успешно выполняются на рабочей станции с Linux, удостоверьтесь, что они так же себя ведут и на других ОС. Если не проверили - приготовьтесь к неожиданностям.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Может показаться, что NIO.2 поддерживается только в Java 7, и если ваше приложение работает на Java 6, то вы не сможете его использовать. Так же пока еще нет поддержки в NIO.2 каналов, работающих с датаграмами <em>(datagram channels)</em> (для приложений использующих UDP), поэтому использование NIO.2 ограничивается только TCP протоколом. Netty успешно скрывает эту проблему, и предоставляет общий API, который работает одинаково и на Java 6 и на Java 7. Не придется беспокоиться о версии Java, Netty API будет работать одинаково хорошо и предоставлять простой и удобный интерфейс.</p>
</div>
</div>
<div class="sect2">
<h3 id="_Использовать_bytebuffer_или_нет"><a class="anchor" href="#_Использовать_bytebuffer_или_нет"></a>Использовать ByteBuffer &#8230;&#8203; или нет</h3>
<div class="paragraph">
<p>Как вы видели ранее, ByteBuffer используется, как контейнер данных. К сожалению, JDK не имеет реализации контейнера ByteBuffer, которая бы позволяла обернуть массив экземпляров ByteBuffer. Эта функциональность бы очень пригодилась для минимизации количества копирований данных. Если вы вдруг решили реализовать эту структуру самостоятельно, не теряйте зря время, ByteBuffer имеет приватный конструктор, и поэтому невозможно от него наследоваться.
Netty предоставляет свою реализацию ByteBuffer, которая обходит эти ограничения и предоставляет несколько вариантов конструкторов, методов для ByteBuffer в своем простом API.</p>
</div>
</div>
<div class="sect2">
<h3 id="_Рассеивание_данных_и_сбор_em_scattering_and_gathering_may_leak_em"><a class="anchor" href="#_Рассеивание_данных_и_сбор_em_scattering_and_gathering_may_leak_em"></a>Рассеивание данных и сбор <em>(Scattering and gathering may leak)</em></h3>
<div class="paragraph">
<p>Многие реализации каналов <em>(channel)</em> поддерживают рассеивание данных и сбор <em>(scattering and gathering)</em>. Этото функционал позволяет читать и писать из нескольких экземпляров ByteBuffer одновременно, при этом с большей производительностью. Таким способом устроено ядро операционной системы, которое дает большую производительность на чтение/запись, потому что ядро ОС гораздо ближе к "железу", и знает как обрабатывать данные наиболее эффективным способом.
Рассеивание/сбор часто используется для разделения разных экземпляров ByteBuffer для того, чтобы обрабатывать каждый экземпляр отдельно. Например, если мы захотим, чтобы заголовок находился в одном ByteBuffer, а тело с данными в другом.
На рисунке показано как осуществляется рассеивающееся чтение. Мы передаем массив экземпляров ByteBuffer в ScatteringByteChannel и данные "рассеиваются" с одного канала <em>(channel)</em> к разным буферам.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../img/gathering.png" alt="gathering">
</div>
<div class="title">Figure 3. Рассеивание</div>
</div>
<div class="paragraph">
<p>Сбор <em>(Gathering)</em> работает похожим образом, но данные наоборот - записываются в канал <em>(channel)</em>. Вы передаете массив экземпляров ByteBuffer в метод GatheringByteChannel.write() и данные собираются из буферов в канал <em>(channel)</em>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../img/gathering1.png" alt="gathering1">
</div>
<div class="title">Figure 4. Сбор</div>
</div>
<div class="paragraph">
<p>К сожалению, эта функциональность была сломана до одной из последних обновлений Java 6 и Java 7, использование ее приводило к утечке памяти и OutOfMemoryError. Нужно быть осторожным, когда используешь рассеивание/сбор <em>(scattering/gathering)</em> , и удостовериться что используется необходимая версия Java.</p>
</div>
</div>
<div class="sect2">
<h3 id="_Подавление_известного_бага_с_событием_epoll_em_squashing_the_famous_epoll_bug_em"><a class="anchor" href="#_Подавление_известного_бага_с_событием_epoll_em_squashing_the_famous_epoll_bug_em"></a>Подавление известного бага с событием epoll <em>(Squashing the famous epoll bug)</em></h3>
<div class="paragraph">
<p>На Linux-подобных операционных системах селектор <em>(selector)</em> использует уведомления <a href=":https://ru.wikipedia.org/wiki/Epoll">epoll</a> об IO событиях над объектом. Этот высоко-производительный способ позволят ОС работать асинхронно с сетевым стэком. К сожалению, известный баг с epoll может привести к неправильному состоянию селектора, что приводит к 100% загрузке CPU и бесконечному ожиданию <em>(spinning)</em>. Единственный способ восстановить состояние - это пересоздать <em>(recycle)</em> старый селектор и переместить зарегистрированный экземпляр канала в только что созданный селектор.
Что же произойдет если метод Selector.select() перестанет блокировать и сразу же вернет результат, даже если ни одного SelectionKeys не будет существовать. Это противоречит тому, что написано в javadoc - <a href=":http://docs.oracle.com/javase/7/docs/api/java/nio/channels/Selector.html#select()">Selector.select() must not unblock if nothing is selected</a>.
Список проблем с epoll ограничен, и Netty пытается автоматически обнаруживать их и предотвращать. Следующий код демонстрирует баг с epoll:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">...
 while (true) {
     int selected = selector.select(); <i class="conum" data-value="1"></i><b>(1)</b>
     Set&lt;SelectedKeys&gt; readyKeys = selector.selectedKeys();
     Iterator iterator = readyKeys.iterator(); <i class="conum" data-value="2"></i><b>(2)</b>
     while (iterator.hasNext()) { <i class="conum" data-value="3"></i><b>(3)</b>
     ...
     ... <i class="conum" data-value="4"></i><b>(4)</b>
 }
}
...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Не блокирует и возвращает 0, если ничего не было выбрано</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Получает все SelectedKeys, Iterator будет пуст и ничего выбрано не будет</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Проходит во всем SelectedKeys из Iterator, но в этот блок кода никогда не зайдет, потому что ничего небудет выбрано</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Дальнейшая работа</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>В итоге получается что небольшой кусок кода съедает весь CPU.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint highlight"><code class="language-java" data-lang="java">...
 while (true) {
    ...
    }
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Значение никогда не будет false, и код зависнет в бесконечном цикле  и постепенно выест весь CPU, тем самым вытесняя остальные процессы.
Это лишь несколько возможных проблеем, с которому можно столкнуться при использовании неблокирующего ввода-вывода. К сожалению, даже после многих лет разработки в этой области некоторые проблемы еще не решены, и Netty успешно
абстрагирует разработчиков от этих проблем.</p>
</div>
</div>
</div>
</div></p>

					<p><em>Share this:</em></p>
          <p style="float:left">
                <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://www.mikemcgarr.com/blog/2015/netty_in_action.html" data-via="SonOfGarr" data-lang="fr">Tweeter</a>
                <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="//platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
                <div class="g-plusone" data-size="medium" data-href="http://www.mikemcgarr.com/blog/2015/netty_in_action.html"></div>
                <script type="IN/Share" data-url="http://www.mikemcgarr.com/blog/2015/netty_in_action.html" data-counter="right"></script>
                <div class="fb-like" data-href="http://www.mikemcgarr.com/blog/2015/netty_in_action.html" data-layout="button_count" data-action="like" data-show-faces="false" data-share="true"></div>
          </p>

          <hr>

          <div id="disqus_thread">
          <script type="text/javascript">
                var disqus_shortname = 'mikemcgarr';
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
          <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
          </div>
        </div>
    </div>

		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
        <p class="muted credit">All posts on this blog are published with a <em>Creative Commons by-nc-sa</em> license.<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"/></a></p>
        <p class="muted credit">&copy; 2015 | Mixed with <a href="http://twitter.github.com/bootstrap/">Bootstrap v2.3.1</a> | Baked with <a href="http://jbake.org">JBake v2.4.0</a></p>
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="/js/jquery-1.9.1.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/run_prettify.js"></script>
    <script type="text/javascript">
      (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/platform.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      })();
    </script>
  </body>
</html>
